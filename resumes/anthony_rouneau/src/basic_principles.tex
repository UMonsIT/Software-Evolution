\documentclass[a4paper,11pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage[pdftex]{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{fullpage}
%
\newcommand{\alinea}{
\hspace*{0.5cm}}
%
\renewcommand{\thesection}{\arabic{section}}
%
\newtheorem{definition}{Definition}
\newtheorem{law}{S.E. law}
%
\title{Basic Principles of Software Evolution: Summary}
\author{Anthony Rouneau}
%
\begin{document}
\maketitle
\newpage
%
\section{Technical aspects of Software Evolution}
	Here are some technical aspects of the
		Software Evolution.
	%
	\begin{itemize}
		\setlength{\itemsep}{0pt}		
		\setlength{\parskip}{0pt}		
		\setlength{\parsep}{0pt}	
		\item Version management
		\item Software quality measurement
			and improvement
		\item Legacy systems and migration
		\item Reverse Engineering and program
			comprehension
		\item Model-driven evolution
		\item Change propagation and program
			comprehension
		\item Traceability
		\item Co-evolution
		\item Consistency maintenance
		\item Regression testing
		\item Design for change
		\item Visualisation and statistical
			analysis of evolution histories
		\item Software product lines and 
			product families
	\end{itemize}
	%
	\begin{definition}
		\textbf{Reverse engineering} --
			Process of analysing a project to fully
			understand it and to extract the key
			issues. Mostly, the system is a 
			large legacy system with a poor
			 documentation and in a bad shape.
			 Visualisation techniques can help.
	\end{definition}
	%
	\begin{definition}
		\textbf{Re-engineering} -- 
			Horseshoe process (cf. figure
			\ref{fig:reengineering}) that targets
			to rethink a project in order to
			address one or multiple problems.
	\end{definition}
	%
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.2]{figures/%
			reengineering}
		\caption{Re-engineering}%
		\label{fig:reengineering}
	\end{figure}\noindent
	%
	\subsection{Visualisation techniques}
		Visualisation techniques are useful to
			\textbf{understand} the way a
			software works, but also to understand
			the \textbf{complexity} of a software.
			There is five types of visualisation.
		%
		\subparagraph{Code duplication}
			The duplication of the code can be 
			visualised as a dotplot, showing 
			the similarity between multiple
			files. \textit{CCFinderX, Duploc}
		%			
		\subparagraph{Dependencies}
			The dependencies between the class
			or with external libraries can
			be shown of graphs, binding 
			two dependant classes. \textit{Stan, 
			IntelliJ IDEA, ...}
		%
		\subparagraph{Metrics}
			The quality metrics can be 
			visualised on multiple sort of
			views, 2D, 3D, ... \textit{3D Treemap,
			Sunburst, ...}
		%
		\subparagraph{Change}
			The change of the software over time
			can be visualised, comparing the 
			different versions. \textit{Chronia}.	
		%
		\subparagraph{Quality}
			The metrics can be summarized into 
			one quality metrics that can be visualised.
			The managerial evolution can be observed
			over time. The complexity can be 
			viewed to ease reverse engineering.
			\textit{Code Crawler, X-Ray, ...}
			\begin{itemize}
				\setlength{\itemsep}{0pt}		
				\setlength{\parskip}{0pt}		
				\setlength{\parsep}{0pt}	
				\item \textbf{Coarse-Grained
					visualisation} -- 	Multiple
					metrics visible in one view.
					Can be used to reverse engineer.
				\item \textbf{Fine-Grained 
					visualisation} -- Class 
					Blueprint views can be used
					to understand classes 
					and class hierarchies, using
					a pattern language.
				\item \textbf{Evolution Matrix} --
					Using a pattern language,
					one can analyse the system 
					evolution and/or the classes
					evolution.
			\end{itemize}
		%
	%
%
\section{Managerial aspects}
	\begin{itemize}
		\item Traditional process model
		\item Evolutionary process model
			\begin{itemize}	
				\setlength{\itemsep}{0pt}		
				\setlength{\parskip}{0pt}		
				\setlength{\parsep}{0pt}	
				\item Staged life-cycle
				\item Iterative and incremental 
					process
				\item Agile methods
			\end{itemize}
		\item Software configuration management
			\begin{itemize}
				\setlength{\itemsep}{0pt}		
				\setlength{\parskip}{0pt}		
				\setlength{\parsep}{0pt}	
				\item Change management
				\item Version management
			\end{itemize}
		\item Estimation techniques
			\begin{itemize}	
				\setlength{\itemsep}{0pt}		
				\setlength{\parskip}{0pt}		
				\setlength{\parsep}{0pt}	
				\item Change impact analysis
				\item Effort estimation
				\item Cost estimation
				\item Change metrics
			\end{itemize}
	\end{itemize}
	%
	\subsection{Evolution process}
		The evolution of a software follows steps,
			defined in the chosen process model.
			The \textbf{urgent changes} can bypass 
			such model to be available faster.
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.75]{figures/%
				waterfall.png}
			\caption{Traditional waterfall process model}
		\end{figure}\noindent
		%
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.75]{figures/%
				evolutionary.png}
			\caption{Evolutionary process}
		\end{figure}\noindent
		%
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.4]{figures/%
				mini_change.PNG}
			\caption{Evolution mini-cycle model}
		\end{figure}\noindent
	%
	\subsection{Software configuration management}
		\noindent
		Changing a part of the software may
			affect other parts. Software
			configuration management consists 
			of predicting the total number
			of changes required by an evolution and
			making the software the less 
			subject to change by reducing
			coupling and dependences.
		%
		\begin{definition}
			\textbf{Ripple effect} -- 
				The phenomenon where a change 
				in one piece of a software system
				affects at least one other area of 
				the same software system (either
				directly or indirectly).
		\end{definition}
		%
		\begin{definition}
			\textbf{Change propagation} --
				Occurs when making a change to one 
				part of a software system
				requires other system parts that 
				depend on it to be changed as well.
				These dependent system parts can on 
				their turn require changes in
				other system parts. In this way, a 
				single change to one system part
				may lead to a propagation of changes 
				to be made throughout the
				entire software system.
		\end{definition}
		%
		When a component is changed, visit every
			module that includes the component
			and check if it still fits.
			If a change is required, the same process
			is applied, taking the module as
			component.
		%
	%
%
\newpage
%
\section{Software Maintenance}\noindent
	The software maintenance is used
		to avoid \textbf{large} software to become 
		legacy systems. In fact, adding
		new functionalities without 
		considering code quality gives rise
		to \textbf{technical debt}.
	\begin{definition}
		\textbf{Technical debt} -- 
			Lack of quality in the code due to 
			modifications done in a hurry.
			The project is unclean while the debt
			has not been paid back through 
			re-engineering. Measured in days; 
			an estimation of time that would take
			to accomplish the pending tasks.
	\end{definition}
	%
	\begin{definition}
		\textbf{Software maintenance (1)} -- 
			The process of modifying a software 
			system or component after delivery 
			to correct faults, improve 
			performance or other attributes, 
			or adapt to a changed environment. 
			Maintenance costs exceed development 
			costs with at least a factor 2
	\end{definition}
	%
	\begin{definition}
		\textbf{Software maintenance (2)} -- 
			The software product undergoes 
			modification to code and associated 
			documentation due to a problem or
			the need for improvement. 
			The objective is to modify
			the existing software product 
			while preserving its integrity
	\end{definition}\noindent
	%
	The software change is :
	\begin{itemize}
		\setlength{\itemsep}{0pt}		
		\setlength{\parskip}{0pt}		
		\setlength{\parsep}{0pt}	
		\item \textbf{Unpredictable} --
			All the changes and bugs can not be
			anticipated in the design.
		\item \textbf{Expensive} --
			You generally don't get paid to solve bugs but
			to develop as fast as possible.
		\item \textbf{Difficult}-- The errors are hard
			to find and the source code can be messy.
	\end{itemize}
	%
	\subsection{Legacy system}
		Characteristics : 
		\begin{itemize}
			\setlength{\itemsep}{0pt}		
			\setlength{\parskip}{0pt}		
			\setlength{\parsep}{0pt}	
			\item Original developers no longer
				available
			\item Outdated development methods
				used
			\item Extensive patches and modifications 
				have been made
			\item Missing or outdated documentation
		\end{itemize}
	%
	\subsection{Parnas' ageing software}
		Symptoms :
		\begin{itemize}
			\item Lack of knowledge
				\begin{itemize}
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item Insufficient, inconsistent or
						obsolete documentation
					\item Departure of original 
						developers
					\item Disappearance of inside 
						knowledge about the system
					\item Missing tests
				\end{itemize}
			\item Code symptoms
				\begin{itemize}
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item Duplicated code, code smells, 
						lack of modularity
					\item Lack of overall structure 
						or architecture
				\end{itemize}
			\item Process symptoms
				\begin{itemize}	
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item Constant need for bug fixes
						Too long time to fix bugs or to 
						add new functionality
					\item Difficult to separate
						functionalities
				\end{itemize}
		\end{itemize}
		%
	%
	\newpage
	%
	\subsection{Necessity of software change}
		Software change is inevitable because:
		%
		\begin{itemize}
			\setlength{\itemsep}{0pt}		
			\setlength{\parskip}{0pt}		
			\setlength{\parsep}{0pt}	
			\item New requirements emerge when the 
				software is used or developed.
			\item The business environment changes.
				\begin{itemize}	
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item New customers
					\item New demands
					\item Organisational changes
					\item Competitors
				\end{itemize}
			\item Errors must be repaired
				\begin{itemize}
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item Bug fix routine
					\item Emergency fix
				\end{itemize}
			\item Hardware changed
			\item Improvements needed in efficiency
			\item New technologies have to be used
			\item Changes in data formats
				\begin{itemize}
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item New standards
					\item New currency, ...
				\end{itemize}
		\end{itemize}
		%
	%
	\subsection{Types of software maintenance}
		\begin{itemize}
			\setlength{\itemsep}{0pt}		
			\setlength{\parskip}{0pt}		
			\setlength{\parsep}{0pt}	
			\item \textbf{Adaptive} -- 
				Adapt a software after delivery 
				to support new technologies
			\item \textbf{Corrective} -- 
				Repair errors discovered after delivery
			\item \textbf{Perfective} -- 
				Add new functionalities to the 
				software or improve it after delivery\\
				\alinea\alinea\alinea
				\alinea
				\alinea$\Longrightarrow$ \textit{main
					reason}
			\item \textbf{Preventive} --
				Correct latent faults before they
				become effective ones.
		\end{itemize}
		%
		\begin{center}
			\begin{tabular}{|c|c|c|}
				\hline
				\textit{When? / Why?} & 
					\textbf{Correction} &
					\textbf{Enhancement}\\
				\hline
				\textbf{Proactive} (before it happens) & 
					Preventive & Perfective\\
				\hline		
				\textbf{Reactive} (after it happened) & 
					Corrective & Adaptive\\			
				\hline
			\end{tabular}
		\end{center}
		%
		\begin{figure}[H]
			\centering
			\includegraphics[scale=0.6]{figures/types.PNG}
		\end{figure}\noindent
		%
	%
	\subsection{Seven deadly sins}\noindent
		According to SonarQube, there are seven
			deadly technical debt that should be 
			avoid as much as possible.	
		\begin{itemize}
			\setlength{\itemsep}{0pt}		
			\setlength{\parskip}{0pt}		
			\setlength{\parsep}{0pt}	
			\item Bugs and Potential Bugs
			\item Coding Standards Breach
			\item Duplications
			\item Lack of Unit Tests
			\item Bad Distribution of Complexity
			\item Spaghetti Design
				\begin{itemize}	
					\setlength{\itemsep}{0pt}		
					\setlength{\parskip}{0pt}		
					\setlength{\parsep}{0pt}	
					\item Cyclic dependencies
					\item High coupling
					\item Low cohesion
				\end{itemize}
			\item Not Enough or Too Many Comments
		\end{itemize}
	%
	\subsection{Clones}\noindent
		There are three types of clones
		\begin{itemize}
			\setlength{\itemsep}{0pt}		
			\setlength{\parskip}{0pt}		
			\setlength{\parsep}{0pt}	
			\item \textbf{Type 1} -- Same code,
				except for the line breaks, etc...
			\item \textbf{Type 2} -- Same code,
				except for the variable/method
				names.
			\item \textbf{Type 3} -- Same code 
				modulo some changes/additions.
		\end{itemize}
	%
	\subsection{Bad Smells}
		\begin{definition}
			\textbf{Bad Smells} -- 
				Structures in the code that suggest
				(sometimes scream for) the
				possibility of refactoring.
		\end{definition}
		%
		\begin{definition}
			\textbf{Anti-Pattern} -- 
				Identifies common mistakes and how 
				these mistakes
				can be overcome in refactored solutions.
		\end{definition}\noindent
		
		\paragraph{Anti-Pattern example} 
			\textbf{The Blob} or
			\textbf{God Class}.\\~\\
		$\times$ General form:
		\begin{itemize}
			\setlength{\itemsep}{0pt}
			\setlength{\parskip}{0pt}
			\setlength{\parsep}{0pt}
			\item \textit{Designs where one class
				monopolizes the processing,\\ and other
				classes primarily encapsulate data.}
			\item Key problem is: majority of
				responsibilities are allocated to a 
				single class.
			\item In general it is a procedural design
				$\longrightarrow$ conflicts with OO
				paradigm.
		\end{itemize}
		$\times$ Refactored Solution:
		\begin{itemize}
			\setlength{\itemsep}{0pt}
			\setlength{\parskip}{0pt}
			\setlength{\parsep}{0pt}
			\item Identify or categorize related 
				attributes and operations.
			\item Look for ‘natural homes’ for these
				collections of functionality.
			\item Apply OO Design techniques
				e.g., inheritance, ...
		\end{itemize}
		%
		\paragraph{Bad smells examples}
		\begin{itemize}
			\setlength{\itemsep}{0pt}
			\setlength{\parskip}{0pt}
			\setlength{\parsep}{0pt}
			\item \textbf{Long method} --
				Method that is too long $\rightarrow$
				difficult to understand, change 
				or extend.
			\item \textbf{Large class} -- 
				Class that is trying to do too much
				$\rightarrow$ too many instance
				variables/methods.
			\item \textbf{Long parameter list} --
				Too long method parameter list 
				$\rightarrow$
				difficult to understand.
			\item \textbf{Feature envy} --
				Method interested more in other
				class(es) $\rightarrow$ should 
				moved.
			\item \textbf{Inappropriate intimacy} --
				Two classes are too tightly coupled 
				with each other.
			\item \textbf{Lazy class} --
				Class that is not doing enough.
			\item \textbf{Data class}
				Class that contains data but almost 
				no behaviour.
			\item \textbf{Duplicate code} --
				Redundant code, i.e., code that 
				appears more than once.
			\item \textbf{Comments}
				Comments are misused to compensate 
				for poorly structured code.
		\end{itemize}
		%
		These bad smells can be detected using 
			metrics:
		\begin{itemize}
			\setlength{\itemsep}{0pt}
			\setlength{\parskip}{0pt}
			\setlength{\parsep}{0pt}
			\item \textbf{Long method}
				use a combination of LOC 
				(lines of code) and CC (Cyclomatic
				Complexity).
			\item \textbf{Long parameter lists}
				count number of method paramters.
			\item \textbf{Large class}
				count number of variables and 
				methods.
			\item \textbf{Feature envy}
				use coupling metrics.
			\item \textbf{Inappropriate intimacy}
				use coupling metrics.
		\end{itemize}
		%
	%
	\subsection{Refactoring}
		\begin{definition}
			\textbf{Refactoring} -- 
				A change to the system that leaves its
				behaviour unchanged, but enhances some 
				non-functional quality (simplicity,
				flexibility, understandability, ...).
		\end{definition}
		\paragraph{Refactorin methods example}
			\begin{itemize}
				\setlength{\itemsep}{0pt}
				\setlength{\parskip}{0pt}
				\setlength{\parsep}{0pt}
				\item \textbf{Using a loop} instead of
					declaring all the statements.
				\item \textbf{Encapsulate public field}
					with getters and/or setters.
				\item \textbf{Extract behaviour} into
					another method or class.
				\item \textbf{Extract class/method/%
					subclass}.
				\item \textbf{Move method} into another
					class.
			\end{itemize}
			%
		%
		\paragraph{Refactor categories}
			\begin{itemize}
				\setlength{\itemsep}{0pt}
				\setlength{\parskip}{0pt}
				\setlength{\parsep}{0pt}
				\item \textbf{Creating template methods}
					\begin{itemize}
						\setlength{\itemsep}{0pt}
						\setlength{\parskip}{0pt}
						\setlength{\parsep}{0pt}
						\item Cut methods in smaller 
							pieces to separate the
							common behaviour from
							specialised one.
							$\rightarrow$ 
							Use inheritance mechanism
							to redefine methods.
						 \item Can be used to improve
						 	reuse, to remove duplicated
						 	code, …
					\end{itemize}
				\item \textbf{Optimising class 
					hierarchies}
					\begin{itemize}
						\setlength{\itemsep}{0pt}
						\setlength{\parskip}{0pt}
						\setlength{\parsep}{0pt}
						\item Insert or remove classes 
							in a hierarchy and
							redistribute functionality 
							over these classes.
						\item Can be used to increase
							cohesion, simplify
							interfaces, remove duplicated
							code.
					\end{itemize}
				\item \textbf{Incorporating composition
					relationships}
					\begin{itemize}
						\setlength{\itemsep}{0pt}
						\setlength{\parskip}{0pt}
						\setlength{\parsep}{0pt}
						\item Convert inheritance into
						aggregation when inheritance is
						overused or incorrectly used.
					\end{itemize}
			\end{itemize}
			%
		%
		\newpage
		%
		\paragraph{Size of refactors}
			\begin{itemize}
				\setlength{\itemsep}{0pt}
				\setlength{\parskip}{0pt}
				\setlength{\parsep}{0pt}
				\item \textbf{Small}
					\begin{itemize}
						\setlength{\itemsep}{0pt}
						\setlength{\parskip}{0pt}
						\setlength{\parsep}{0pt}
						\item Short time to proceed.
						\item Instant satisfaction.
					\end{itemize}
				\item \textbf{Big}
					\begin{itemize}
						\setlength{\itemsep}{0pt}
						\setlength{\parskip}{0pt}
						\setlength{\parsep}{0pt}
						\item Long time ($\sim$ 1 month).
						\item Agreement with the team
							needed.
						\item No instant satisfaction and
							no visible progress.
					\end{itemize}
			\end{itemize}
			%
		%
		\paragraph{Utility of refactoring}
			Apart from making the code simpler and 
				have better quality metrics, 
				refactoring can be used to generate
				\textbf{change metrics.} The structures of
				the well-known refactors can be detected
				between two version of a software.
				Nonetheless, Refactoing can lead to 
				\textbf{conflicts} when applied to
				frameworks used in some little software.
				Those software must change along with
				the framework, which is not easy.
			%
		%
		\paragraph{Model refactoring}
			Refactors can be applied to diagrams (UML, ...)
			\begin{definition}
				\textbf{Model Driven Engineering} --
					Develop application using models
					only. Everything can be considered
					as model (source code, syntax, ...).
					Implies a higher level of abstraction
					and allows anybody that know the
					syntax of the model to understand 
					the software.					
			\end{definition}\noindent
			Multiple refactors can be applied to UML
				diagrams:
			\begin{itemize}
				\setlength{\itemsep}{0pt}
				\setlength{\parskip}{0pt}
				\setlength{\parsep}{0pt}
				\item \textbf{Class diagrams} -- 
					Similar to method and class
					classic refactors, move methods,
					push up, pull down, ...
				\item \textbf{State machines} -- 
					Merge states, split states,
					create composite state,
					flatten states, ...
				\item \textbf{Activity diagrams} --
					Paralleling independent activities,
					concurrent state serialisation.
			\end{itemize}
		%
	%
%
\section{Product Line Engineering}
	\begin{definition}
		\textbf{Software Product Line} -- 
			Set of software-intensive systems sharing 
			a common, managed set of features that
			satisfy the specific needs of a particular
			market segment or
			mission and that are developed from a common
			set of core assets in a prescribed way.
	\end{definition}
	A (Software) Product Line is a Product Family that 
	is engineered in a planned and systematic way so as 
	to maximise reuse.
	This can be divided into two development activities.
	\begin{enumerate}
		\setlength{\itemsep}{0pt}		
		\setlength{\parskip}{0pt}		
		\setlength{\parsep}{0pt}	
		\item \textbf{Domain engineering} -- 
			\textit{Development for reuse.} (model
			development with max common features).
		\item \textbf{Application engineering} --
			\textit{Development with reuse.} (using 
			models, frameworks to develop something
			new).
	\end{enumerate}
	The main challenges in Product line engineering
	are :
	\begin{enumerate}
		\setlength{\itemsep}{0pt}		
		\setlength{\parskip}{0pt}		
		\setlength{\parsep}{0pt}	
		\item \textbf{Adoption} --
			\textit{The product family must cover enough
			products so it is viable to engineer
			model with common features.} It is useless
			to spend time and money in establishing 
			a general model for a family of 3 products.
		\item \textbf{Fitness-for-purpose} --
			\textit{Some business case and requirements
			are sometimes too precise and hard to model,
			and it would cost too much as requirements
			engineering is already the most difficult
			task in single system development.}
		\item \textbf{Variability management} --
			\textit{Establish which features are
			common/optional and deal with feature
			interaction.}
	\end{enumerate}
	%
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{figures/%
			product_line_1.png}
		\caption{Feature diagram}
		\label{fig:feature_diagram:1}
	\end{figure}\noindent
	%
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.65]{figures/%
			product_line_2.png}
		\caption{Feature diagram}
	\end{figure}\noindent
	%
	\begin{itemize}
		\setlength{\itemsep}{0pt}
		\setlength{\parskip}{0pt}
		\setlength{\parsep}{0pt}
		\item \textbf{Commonality} -- 
			List of the features that appear in all
			products.
		\item \textbf{Variability} -- 
			List of the features that appear not
			in all products.
		\item \textbf{Dead feature} --
			Feature present in the diagram that
			appears in no product.
	\end{itemize}
	%
%
\section{Data extraction}\noindent
	One could want to extract data from numerous database
		concerning an Open Source project. The main
		challenges to do so are:
	%
	\begin{itemize}
		\setlength{\itemsep}{0pt}		
		\setlength{\parskip}{0pt}		
		\setlength{\parsep}{0pt}	
		\item \textbf{Identity Merging} -- 
			A single contributor can have his name/nickname
			spelled different ways for different sites
			(inverse first and last name, "accent" missing,
			punctuation, middle names, nickname for a 
			specific project, ...). One solution
			is to compute the distance between two
			names (Levenstein distance for Strings)
			and merge the similar names. Manual 
			post-process is	necessary.
		\item \textbf{Workload analysis} --
			It may be useful to analyse the main
			topic on which each contributor has 
			worked. The commits on the git repository
			are analysed after the files of the project
			have been labelled with their respective topic.
			The $\overset{\sim}{T}$	procedure allows to
			identify the main topic and the secondary
			topics of the project.
		\item \textbf{Community analysis} -- 
			If the developers focus on a single task,
			it is likely that the project (large) is
			heterogeneous, because a large project requires
			a lot of different qualification to release
			(graphical, literal, code dev, ...).
	\end{itemize}
	%
%
\end{document}
